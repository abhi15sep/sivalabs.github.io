<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>springboot on SivaLabs</title>
    <link>https://sivalabs.github.io/categories/springboot/</link>
    <description>Recent content in springboot on SivaLabs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Jan 2020 04:59:17 +0530</lastBuildDate>
    
	<atom:link href="https://sivalabs.github.io/categories/springboot/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Creating Yeoman based SpringBoot Generator</title>
      <link>https://sivalabs.github.io/2020/01/creating-yeoman-based-springboot-generator/</link>
      <pubDate>Wed, 29 Jan 2020 04:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2020/01/creating-yeoman-based-springboot-generator/</guid>
      <description>I have been working with Spring and SpringBoot for many years and I needed to create lot of Spring(Boot) applications for various reasons like blog posts, sample apps, book sample code and for my personal learning as well. So, I needed some tool/mechanism to quickly create Spring(Boot) application with most commonly used configuration.
I know we have the most popular SpringBoot Initializer to create SpringBoot applications. But, it generates the application with only selected starter dependencies added and nothing more.</description>
    </item>
    
    <item>
      <title>Testing SpringBoot Applications</title>
      <link>https://sivalabs.github.io/2019/10/spring-boot-testing/</link>
      <pubDate>Mon, 07 Oct 2019 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2019/10/spring-boot-testing/</guid>
      <description>SpringBoot is the most popular tech stack for building Java based REST APIs. In this tutorial we will learn how to write tests for SpringBoot applications.
 Create SpringBoot Application Unit Testing using JUnit 5 and Mockito Integration Testing using TestContainers Testing MicroService Integrations using MockServer  As we all know, we write unit tests for testing single component (a class) behaviour where as we write integration tests for testing a feature which may involve interaction with multiple components.</description>
    </item>
    
    <item>
      <title>SpringBoot Best Practices</title>
      <link>https://sivalabs.github.io/2019/05/spring-boot-best-practices/</link>
      <pubDate>Tue, 14 May 2019 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2019/05/spring-boot-best-practices/</guid>
      <description>I have been working with SpringBoot for many years and over the time I worked with many SpringBoot based codebases. There are few common mistakes that I observe in the projects that use SpringBoot. So, I thought of writing down few good practices that can be followed while using SpringBoot.
1. Understand SpringBoot Core Concepts I know, this sounds very obvious but I see many developers jumping onto using SpringBoot without having any prior knowledge on Spring, Dependency Injection.</description>
    </item>
    
    <item>
      <title>MicroServices - Part 6 : Distributed Tracing with Spring Cloud Sleuth and Zipkin</title>
      <link>https://sivalabs.github.io/2018/03/microservices-part-6-distributed-tracing-with-spring-cloud-sleuth-and-zipkin/</link>
      <pubDate>Tue, 20 Mar 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/03/microservices-part-6-distributed-tracing-with-spring-cloud-sleuth-and-zipkin/</guid>
      <description>One of the challenges in microservices architecture is the ability to debug issues. A simple user action might trigger a chain of downstream microservice calls. It would be tedious to trace the logs related to a particular user action across microservices. In addition to that, we might want to track down why a certain microservice call is taking so much time. We can use Spring Cloud Sleuth to handle these kinds of issues.</description>
    </item>
    
    <item>
      <title>MicroServices - Part 5 : Spring Cloud Zuul Proxy as API Gateway</title>
      <link>https://sivalabs.github.io/2018/03/microservices-part-5-spring-cloud-zuul-proxy-as-api-gateway/</link>
      <pubDate>Thu, 15 Mar 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/03/microservices-part-5-spring-cloud-zuul-proxy-as-api-gateway/</guid>
      <description>In microservices architecture, there could be a number of API services and few UI components that are talking to APIs. As of now, many microservices based application still use monolithic front-ends where the entire UI is built as a single module. You may choose to go with micro-frontends where the UI is also decomposed into multiple microservice talking to APIs to get the relevant data. Instead of letting UI know about all our microservices details we can provide a unified proxy interface that will delegate the calls to various microservices based on URL pattern.</description>
    </item>
    
    <item>
      <title>MicroServices - Part 4 : Spring Cloud Circuit Breaker using Netflix Hystrix</title>
      <link>https://sivalabs.github.io/2018/03/spring-cloud-netflix-circuit-breaker/</link>
      <pubDate>Mon, 12 Mar 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/03/spring-cloud-netflix-circuit-breaker/</guid>
      <description>In the microservices world, to fulfill a client request one microservice may need to talk to other microservices. We should minimize this kind of direct dependencies on other microservices but in some cases it is unavoidable. If a microservice is down or not functioning properly then the issue may cascade up to the upstream services. Netflix created Hystrix library implementing Circuit Breaker pattern to address these kinds of issues. We can use Spring Cloud Netflix Hystrix Circuit Breaker to protect microservices from cascading failures.</description>
    </item>
    
    <item>
      <title>MicroServices - Part 3 : Spring Cloud Service Registry and Discovery</title>
      <link>https://sivalabs.github.io/2018/03/microservices-springcloud-eureka/</link>
      <pubDate>Thu, 08 Mar 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/03/microservices-springcloud-eureka/</guid>
      <description>In the microservices world, Service Registry and Discovery plays an important role because we most likely run multiple instances of services and we need a mechanism to call other services without hardcoding their hostnames or port numbers. In addition to that, in Cloud environments service instances may come up and go down anytime. So we need some automatic service registration and discovery mechanism. Spring Cloud provides Service Registry and Discovery features, as usual, with multiple options.</description>
    </item>
    
    <item>
      <title>MicroServices - Part 2 : Configuration Management with Spring Cloud Config and Vault</title>
      <link>https://sivalabs.github.io/2018/03/microservices-part-2-configuration-management-spring-cloud-config-vault/</link>
      <pubDate>Mon, 05 Mar 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/03/microservices-part-2-configuration-management-spring-cloud-config-vault/</guid>
      <description>In MicroServices using Spring Boot &amp;amp; Spring Cloud – Part 1 : Overview, we took a brief look at what are micro-services and how we can use SpringBoot and SpringCloud to build micro-services.
In this post, we are going to learn:
 What is the need for Spring Cloud Config and Vault? Create our first micro-service: catalog-service Create Spring Cloud Config Server Using Vault for storing sensitive data  MicroServices using Spring Boot &amp;amp; Spring Cloud</description>
    </item>
    
    <item>
      <title>MicroServices using Spring Boot &amp; Spring Cloud – Part 1 : Overview</title>
      <link>https://sivalabs.github.io/2018/03/microservices-using-springboot-spring-cloud-part-1-overview/</link>
      <pubDate>Fri, 02 Mar 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/03/microservices-using-springboot-spring-cloud-part-1-overview/</guid>
      <description>Nowadays MicroServices is the hot buzzword in software development and many organizations prefer building their enterprise applications using MicroServices architecture. In Java community, SpringBoot is the most widely used framework for building both monoliths and microservices. I am planning to write a series of articles covering how to build microservices using SpringBoot and SpringCloud.
In this article we are going to learn about following:
 Monoliths what are MicroServices? Advantages of MicroServices Challenges with MicroServices Why SpringBoot &amp;amp; SpringCloud are a good choice for MicroServices?</description>
    </item>
    
    <item>
      <title>Why SpringBoot is so popular and how to learn SpringBoot effectively?</title>
      <link>https://sivalabs.github.io/2018/02/why-springboot-so-popular-how-to-learn-springboot/</link>
      <pubDate>Thu, 22 Feb 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/02/why-springboot-so-popular-how-to-learn-springboot/</guid>
      <description>SpringBoot is the most popular and widely used Java framework. Occasionally this discussion of “Why is SpringBoot so popular?” come between me and my friends/colleagues. Also, I do get emails from various people asking “Spring is huge and how to learn it quickly?”. In this post, I will try to answer these 2 questions.
Why is SpringBoot so popular? There could be many reasons why Spring and SpringBoot are very popular, but in my opinion following are the key reasons:</description>
    </item>
    
    <item>
      <title>SpringBoot Messaging with RabbitMQ</title>
      <link>https://sivalabs.github.io/2018/02/springboot-messaging-rabbitmq/</link>
      <pubDate>Tue, 20 Feb 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/02/springboot-messaging-rabbitmq/</guid>
      <description>RabbitMQ is one of the popular message broker solutions and provides client libraries to be used from various programming languages including Java, Scala, .NET, Go, Python, Ruby, PHP etc. In this tutorial, we will learn how to use RabbitMQ message broker to send and receive messages from a SpringBoot application. We will also look at how to send messages as JSON payloads and how to deal with errors using Dead Letter Queues (DLQ).</description>
    </item>
    
    <item>
      <title>Session Management using Spring Session with JDBC DataStore</title>
      <link>https://sivalabs.github.io/2018/02/session-management-using-spring-session-jdbc-datastore/</link>
      <pubDate>Wed, 07 Feb 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/02/session-management-using-spring-session-jdbc-datastore/</guid>
      <description>In web applications, user session management is very crucial for managing user state. In this article, we are going to learn about what are the approaches we have been following to manage user sessions in a clustered environment and how we can use Spring Session to implement it in a much simpler and more scalable way.
Typically in production environments, we will have multiple server nodes with a load balancer in front of them and all the client traffic will be coming through the load balancer to one of the server nodes.</description>
    </item>
    
    <item>
      <title>CI/CD for SpringBoot applications using Travis-CI</title>
      <link>https://sivalabs.github.io/2018/01/ci-cd-springboot-applications-using-travis-ci/</link>
      <pubDate>Wed, 24 Jan 2018 07:59:17 +0530</pubDate>
      
      <guid>https://sivalabs.github.io/2018/01/ci-cd-springboot-applications-using-travis-ci/</guid>
      <description>In this article we are going to learn how we can use Travis CI for Continuous Integration and Continuous Deployment (CI/CD) of a SpringBoot application. We will learn how to run maven build goals, perform test coverage validation using JaCoCo plugin, Code Quality checks using SonarCloud, build Docker image and push it to DockerHub and finally deploy it to Heroku.
 The source code for this article is at https://github.</description>
    </item>
    
  </channel>
</rss>